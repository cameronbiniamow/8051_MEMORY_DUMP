;Cameron Biniamow
;ECEN 4330
;Lab 1: MEMORY DUMP
;Due: 01/29/2021

;*********************************************************************
;---------------------------------------------------------------------
;---------------------- MAIN -----------------------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
INPUT_MEM_ADDR		EQU	50H		; MEMORY ADDRESS INPUT VALUE RAM LOCATION
INPUT_DATA_TYPE		EQU	51H		; DATA TYPE INPUT VALUE RAM LOCATION
INPUT_MEM_SIZE		EQU	52H		; MEMORY SIZE INPUT VALUE RAM LOCATION

	ORG		0H					; BEGIN PROGRAM AT 0x0000
	ACALL	LCD_INIT			; INITIALIZE LCD

L0:
	ACALL	LCD_MAIN
	ACALL	LCD_MAIN			; INITIALIZE LCD & WRITE MAIN MENU
	ACALL	KEYPAD_READ			; READ INPUT FROM KEYPAD
	ANL		A, #0FH				; MASK LOWER NIBBLE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0DH				; CHECK THAT INPUT VALUE = 'D'
	JZ		L2					; IF CARRY FLAG SET. INVALID INPUT VALUE
	ACALL	INVALID				; IF INPUT VALUE != 'D', INVALID INPUT
	SJMP	L0					; INVALID INPUT. DISPLAY LCD MAIN MENU
L2:
	ACALL	DUMP				; INPUT VALUE = 'D'. BEGIN MEM DUMP

INVALID:
	ACALL	LCD_CLEAR			; CLEAR LCD. MOVE CURSOR TO R1, C1
	MOV		DPTR, #INVALID_INPUT
	ACALL	LCD_STRING			; PRINT 'INVALID INPUT.' ON LCD
	MOV		A, #03H				; LOAD DELAY COUNTER
	ACALL	DELAY_sec			; 3sec DELAY
	RET


;---------------------------------------------------------------------
;---------------------- MAIN END -------------------------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;---------------------- LCD MAIN MENU --------------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
; INITIALIZES LCD (16 x 2)
; PRINTS:       "[NAME] ECEN4330" 
;               "D-DUMP"

LCD_MAIN:
	ACALL	LCD_CLEAR
	MOV		DPTR, #MYNAME		; POINTS TO NAME STRING 
	ACALL	LCD_STRING			; WRITES STRING TO LCD
	MOV		A, ' '
	ACALL	LCD_CHAR			; WRITES ' ' TO LCD
	MOV		DPTR, #COURSE		; POINTS TO COURSE STRING
	ACALL	LCD_STRING			; WRITES STRING TO LCD
	ACALL	LCD_2NDLINE			; MOVES CURSORS TO SECOND LINE OF LCD
	MOV		DPTR, #D_DUMP		; POINTS TO D-DUMP STRING
	ACALL	LCD_STRING			; WRITES STRING TO LCD
	RET

;---------------------------------------------------------------------
;---------------------- LCD MAIN MENU END ----------------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;--------------------------- D-DUMP ----------------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
; DISPLAYS MEMORY DUMP MENU ON LCD
; READS USER MEMORY ADDRESS & BLOCK SIZE INPUT FROM KEYPAD
; RETURNS DATA STORED AT THE RESPECTIVE MEMORY ADDRESS IN HEX


;------------------------------------
; PROMPT USER TO ENTER MEMORY ADDRESS
; INPUT MUST BE IN HEX & 2 DIGITS
; LCD DISPLAYS INPUT VALUES AS THEY ARE PRESSED
; PACKS INPUT VALUES INTO 1 BYTE & STORES IN RAM
; AFTER 2ND VALUE IS PRESSED, NEXT PROMPT BEGINS
;------------------------------------

DUMP:
	ACALL	MEMORY_ADDRESS_INPUT; PROMPT & READ STARTING MEMORY ADDRESS
	ACALL	DATA_TYPE_INPUT		; PROMPT & READ DATA TYPE
	ACALL	DATA_TYPE_CHECK		; CHECK DATA TYPE FOR VALID INPUT
	ACALL	BLOCK_SIZE_INPUT	; PROMPT & READ BLOCK SIZE
	ACALL	MEMORY_ADDRESS_WRITE1; WRITE MEMORY ADDRESS TO LCD
	ACALL	DATA_WRITE			; WRITE MEMORY DATA TO LCD


;------------------------------------
; PROMPT USER TO ENTER STARTING MEMORY ADDRESS
; INPUT VALUE IS READ FROM KEYPAD
; INPUT VALUE IS 2 DIGITS IN HEX
; INPUT VALUE IS DISPLAYED ON LCD AS KEYS ARE PRESSED
; INPUT VALUE IS STORED IN RAM
;------------------------------------

MEMORY_ADDRESS_INPUT:
	ACALL	LCD_CLEAR			; CLEAR LCD
	MOV		DPTR, #BLOCK_SIZE_0
	ACALL	LCD_STRING			; WRITE "ENTER MEM ADDR:" ON LCD
	ACALL	KEYPAD_READ			; READ MEM ADDRESS INPUT FROM KEYPAD
	MOV		R7, A				; HOLD UPPER NIBBLE INPUT VALUE IN R7
	ACALL	LCD_2NDLINE			; MOVE CURSOR TO 2ND LINE
	MOV		A, R7
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT VALUE TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII VALUE TO LCD
	ACALL	DELAY				; 1ms DELAY
	ACALL	KEYPAD_READ			; READ MEM ADDRESS INPUT FROM KEYPAD
	MOV		R6, A				; HOLD LOWER NIBBLE INPUT VALUE IN R6
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT VALUE TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII VALUE TO LCD
	MOV		A, R7
	ANL		A, #0FH				; MASK LOWER NIBBLE
	SWAP	A					; SWAP NIBBLES
	MOV		B, R6
	ANL		B, #0FH				; MASK LOWER NIBBLE
	ORL		A, B				; PACK INPUT VALUES INTO 1 BYTE
	MOV		R0, #INPUT_MEM_ADDR	; LOAD INPUT MEM ADDRESS 
	MOV		@R0, A				; STORE INPUT MEM ADDRESS IN RAM
	RET


;------------------------------------
; PROMPT USER TO ENTER DATA TYPE
; USER ENTERS:      (1) BYTE
;                   (2) WORD
;                   (3) DOUBLE WORD

; INPUT VALUE IS READ FROM KEYPAD
; INPUT VALUE IS STORED IN RAM
;------------------------------------

DATA_TYPE_INPUT:
	ACALL	LCD_CLEAR			; CLEAR LCD
	MOV		DPTR, #BLOCK_SIZE_1
	ACALL	LCD_STRING			; WRITE "SELECT DATA" ON LCD
	MOV		DPTR, #BLOCK_SIZE_1B
	ACALL	LCD_2NDLINE			; MOVE LCD CURSOR TO 2ND LINE
	ACALL	LCD_STRING			; WRITE "TYPE:" ON LCD
	MOV		A, #03H				; DELAY COUNTER
	ACALL	DELAY_sec			; 3 SECOND DELAY
L9:
	ACALL	LCD_CLEAR			; CLEAR LCD
	MOV		DPTR, #BLOCK_SIZE_2
	ACALL	LCD_STRING			; WRITE "1. BYTE, 2. WORD"
	ACALL	LCD_2NDLINE			; MOVE LCD CURSOR TO 2ND LINE
	MOV		DPTR, #BLOCK_SIZE_3
	ACALL	LCD_STRING			; WRITE "3. DOUBLE WORD"
	ACALL	KEYPAD_READ			; READ INPUT VALUE FROM KEYPAD
	MOV		R6, A				; HOLD INPUT VALUE IN R6
	RET


;------------------------------------
; CHECKS INPUT VALUE FROM KEYPAD
; IF INPUT VALUE IS NOT 1, 2, OR 3, DISPLAY 'INVALID' STRING
; PROMPTS USER TO ENTER DATA TYPE AGAIN AFTER INVALID INPUT
;------------------------------------

DATA_TYPE_CHECK:
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF INPUT = 1
	JZ		MEMORY

	CLR		C					; CLEAR CARRY FLAG
	MOV		A, R6				; RESTORE INPUT VALUE
	SUBB	A, #02H				; CHECK IF INPUT = 2
	JZ		MEMORY

	CLR		C					; CLEAR CARRY FLAG
	MOV		A, R6				; RESTORE INPUT VALUE
	SUBB	A, #03H				; CHECK IF INPUT = 3
	JZ		MEMORY
	ACALL	INVALID				; DISPLAY 'INVALID' STRING IF INVALID INPUT
	LJMP	L9					; PROMPT USER TO ENTER DATA TYPE AGAIN

MEMORY:
	MOV		A, R6				; RESTORE DATA TYPE INPUT VALUE
	MOV		R0, #INPUT_DATA_TYPE; LOAD DATA TYPE RAM ADDRESS
	MOV		@R0, A				; STORE DATA TYPE INPUT VALUE IN RAM
	RET


;------------------------------------
; PROMPT USER TO INPUT DATA SIZE
; DATA SIZE INPUT IS IN HEX. MUST BE 2 DIGITS
; LCD PRINTS INPUT VALUES AS THEY ARE PRESSED
; CHECKS IF INPUT VALUE = 0
; IF INPUT VALUE = 0, DISPLAYS 'INVALID' MESSAGE & PROMPTS USER AGAIN
; INPUT VALUES ARE PACKED INTO 1 BYTE & STORED IN RAM
;------------------------------------

BLOCK_SIZE_INPUT:
	MOV		DPTR, #DATA_SIZE
	ACALL	LCD_CLEAR			; CLEAR LCD
	ACALL	LCD_STRING			; WRITE "ENTER DATA SIZE:" ON LCD
	ACALL	KEYPAD_READ			; READ 1ST DATA SIZE INPUT FROM KEYPAD
	MOV		R7, A				; HOLD 1ST DATA SIZE INPUT IN R7
	ACALL	LCD_2NDLINE			; MOVE CURSOR TO 2ND LINE
	MOV		A, R7				; RESTORE 1ST DATA SIZE INPUT VALUE
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT VALUE TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII VALUE ON LCD
	ACALL	DELAY				; 1ms DELAY
	ACALL	KEYPAD_READ			; READ 2ND DATA SIZE INPUT FROM KEYPAD
	MOV		R6, A				; HOLD 2ND DATA SIZE INPUT IN R6
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT VALUE TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII VALUE TO LCD
	MOV		A, R7				; RESTORE 1ST DATA SIZE INPUT VALUE
	ANL		A, #0FH				; MASK LOWER NIBBLE
	SWAP	A					; SWAP NIBBLES
	MOV		B, R6				; RESTORE 2ND DATA SIZE INPUT VALUE
	ANL		B, #0FH				; MASK LOWER NIBBLE
	ORL		A, B				; PACK 1ST & 2ND INPUT VALUES INTO ACCUMULATOR
	JNZ		STORE				; IF BLOCK SIZE != 0, STORE VALUE IN RAM	
	ACALL	INVALID				; IF BLOCK SIZE = 0, WRITE 'INVALID' STRING
	ACALL	BLOCK_SIZE_INPUT	; BLOCK SIZE INPUT VALUE = 0, PROMPT USER AGAIN
STORE:
	MOV		R0, #INPUT_MEM_SIZE	; LOAD MEMORY SIZE RAM LOCATION
	MOV		@R0, A				; STORE MEMORY SIZE INPUT VALUE IN RAM
	RET

;------------------------------------
; LOAD THE STARTING MEMORY ADDRESS FROM RAM
; CONVERT VALUE TO ASCII & DISPLAY ON LCD
; Ex:   "00:"
;------------------------------------

MEMORY_ADDRESS_WRITE1:
	ACALL	LCD_CLEAR			; CLEAR LCD
	MOV		R1, #INPUT_MEM_ADDR	; LOAD MEMORY ADDRESS RAM LOCATION
	MOV		A, @R1				; LOAD MEMORY ADDRESS FROM RAM

MEMORY_ADDRESS_WRITE2:
	MOV		B, A				; HOLD IN REGISTER B
	PUSH	B					; PUSH MEMORY ADDRESS ONTO THE STACK
	SWAP	A					; SWAP NIBBLES
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		B					; RESTORE STARTING MEMORY ADDRESS
	MOV		A, B
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT INPUT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	MOV		DPTR, #SEMI_COLON
	ACALL	LCD_STRING			; WRITE ":" TO LCD
	RET


;------------------------------------
; LOAD DATA TYPE INPUT VALUE FROM RAM
; CHECKS INPUT VALUE & SELECTS RESPECTIVE DATA TYPE
;------------------------------------

DATA_WRITE:
	MOV		R0, #INPUT_DATA_TYPE; LOAD DATA TYPE RAM LOCATION
	MOV		A, @R0				; LOAD DATA TYPE INPUT VALUE FROM RAM
	MOV		B, A				; HOLD DATA TYPE VALUE IN REGISTER B
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF DATA TYPE = 1
	JZ		BYTE_DATA			; JUMP TO 'BYTE' IF = 1
	MOV		A, B				; RESTORE DATA TYPE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #02H				; CHECK IF DATA TYPE = 2
	JZ		WORD				; JUMP TO 'WORD' IF = 2

	LJMP	DOUBLE_WORD			; JUMP TO 'DOUBLE WORD' IF = 3


;------------------------------------
; BYTE DATA TYPE SELECTED
; MEMORY DATA IS OUTPUT AS BLOCKS OF BYTES
; VALUES ARE IN HEX
; MEMORY SIZE INPUT VALUE IS # OF BYTES DISPLAYED
; Ex:   ## ## ## ## ## ##
;------------------------------------

BYTE_DATA:
	MOV		R0, #INPUT_MEM_SIZE	; LOAD MEMORY SIZE RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY SIZE FROM RAM
	MOV		R7, A				; HOLD INPUT MEMORY SIZE VALUE IN R7
	DEC		R7					; DECREMENT MEMORY SIZE COUNTER
	MOV		R0, #INPUT_MEM_ADDR	; LOAD MEMORY ADDRESS RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY ADDRESS 
	MOV		R1, A				; INPUT MEMORY ADDRESS POINTER
BYTE_LOOP:
	MOV		A, @R1				; LOAD DATA AT INPUT MEMORY ADDRESS
	MOV		B, A				; HOLD DATA IN REG B
	PUSH	B					; PUSH DATA ONTO THE STACK
	SWAP	A					; SWAP NIBBLES
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		B					; RESTORE DATA FROM STACK
	MOV		A, B				; RESTORE DATA
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	ACALL	LCD_2NDLINE			; MOVE LCD CURSOR TO 2ND LINE
	MOV		DPTR, #SCROLL_PAGE
	ACALL	LCD_STRING			; WRITE "0. NEXT, 1. BACK"
	LJMP	SCROLL				; JUMP TO SCROLL FUNCTION

SCROLL_BACK_DATA_TYPE:
	MOV		R0, #INPUT_DATA_TYPE; LOAD DATA TYPE RAM LOCATION
	MOV		A, @R0				; LOAD DATA TYPE INPUT VALUE FROM RAM
	MOV		B, A				; HOLD DATA TYPE VALUE IN REGISTER B
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF DATA TYPE = 1
	JZ		BYTE_LOOP			; JUMP TO 'BYTE' IF = 1
	MOV		A, B				; RESTORE DATA TYPE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #02H				; CHECK IF DATA TYPE = 2
	JZ		WORD_LOOP0			; JUMP TO 'WORD' IF = 2
	MOV		A, B				; RESTORE DATA TYPE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #03H				; CHECK IF DATA TYPE = 3
	JZ		DOUBLE_WORD_LOOP0	; JUMP TO 'DOUBLE WORD' IF = 3

SCROLL_NEXT_DATA_TYPE:
	MOV		R0, #INPUT_DATA_TYPE; LOAD DATA TYPE RAM LOCATION
	MOV		A, @R0				; LOAD DATA TYPE INPUT VALUE FROM RAM
	MOV		B, A				; HOLD DATA TYPE VALUE IN REGISTER B
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF DATA TYPE = 1
	JZ		BYTE_LOOP			; JUMP TO 'BYTE' IF = 1
	MOV		A, B				; RESTORE DATA TYPE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #02H				; CHECK IF DATA TYPE = 2
	JZ		WORD_LOOP0			; JUMP TO 'WORD' IF = 2
	MOV		A, B				; RESTORE DATA TYPE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #03H				; CHECK IF DATA TYPE = 3
	JZ		DOUBLE_WORD_LOOP0	; JUMP TO 'DOUBLE WORD' IF = 3

;------------------------------------
; WORD DATA TYPE SELECTED
; MEMORY DATA IS OUTPUT AS BLOCKS OF WORDS
; VALUES ARE IN HEX
; MEMORY SIZE INPUT VALUE IS # OF WORDS DISPLAYED
; Ex:   #### #### ####
;------------------------------------

WORD:
	MOV		R0, #INPUT_MEM_SIZE	; LOAD MEMORY SIZE RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY SIZE FROM RAM
	MOV		R7, A				; HOLD INPUT MEMORY SIZE VALUE IN R7
	DEC		R7					; DECREMENT MEMORY SIZE COUNTER
	MOV		R0, #INPUT_MEM_ADDR	; LOAD MEMORY ADDRESS RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY ADDRESS 
	MOV		R1, A				; INPUT MEMORY ADDRESS POINTER

WORD_LOOP0:
	MOV		A, #02H				; LOAD LOOP COUNTER

WORD_LOOP:
	PUSH	A					; PUSH LOOP COUNTER ONTO THE STACK
	MOV		A, @R1				; LOAD DATA AT INPUT MEMORY ADDRESS
	MOV		B, A				; HOLD DATA IN REG B
	PUSH	B					; PUSH DATA ONTO THE STACK
	SWAP	A					; SWAP NIBBLES
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		B					; RESTORE DATA FROM STACK
	MOV		A, B				; RESTORE DATA
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		A					; RESTORE LOOP COUNTER
	DEC		A					; DECREMENT LOOP COUNTER
	JZ		WORD_LOOP1			; DECREMENT LOOP COUNTER
	INC		R1					; INCREMENT MEMORY ADDRESS
	LJMP	WORD_LOOP

WORD_LOOP1:
	ACALL	LCD_2NDLINE			; MOVE LCD CURSOR TO 2ND LINE
	MOV		DPTR, #SCROLL_PAGE
	ACALL	LCD_STRING			; WRITE "0. NEXT, 1. BACK"
	LJMP	SCROLL				; JUMP TO SCROLL FUNCTION

;------------------------------------
; DOUBLE WORD DATA TYPE SELECTED
; MEMORY DATA IS OUTPUT AS BLOCKS OF DOUBLE WORDS
; VALUES ARE IN HEX
; MEMORY SIZE INPUT VALUE IS # OF DOUBLE WORDS DISPLAYED
; Ex:   ######## ########
;------------------------------------

DOUBLE_WORD:
	MOV		R0, #INPUT_MEM_SIZE	; LOAD MEMORY SIZE RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY SIZE FROM RAM
	MOV		R7, A				; HOLD INPUT MEMORY SIZE VALUE IN R7
	DEC		R7					; DECREMENT MEMORY SIZE COUNTER
	MOV		R0, #INPUT_MEM_ADDR	; LOAD MEMORY ADDRESS RAM LOCATION
	MOV		A, @R0				; LOAD INPUT MEMORY ADDRESS 
	MOV		R1, A				; INPUT MEMORY ADDRESS POINTER

DOUBLE_WORD_LOOP0:
	MOV		A, #04H				; LOAD LOOP COUNTER

DOUBLE_WORD_LOOP:

	PUSH	A					; PUSH LOOP COUNTER ONTO THE STACK
	MOV		A, @R1				; LOAD DATA AT INPUT MEMORY ADDRESS
	MOV		B, A				; HOLD DATA IN REG B
	PUSH	B					; PUSH DATA ONTO THE STACK
	SWAP	A					; SWAP NIBBLES
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		B					; RESTORE DATA FROM STACK
	MOV		A, B				; RESTORE DATA
	ANL		A, #0FH				; MASK LOWER NIBBLE
	ACALL	INPUT_TO_ASCII		; CONVERT TO ASCII
	ACALL	LCD_CHAR			; WRITE ASCII TO LCD
	POP		A					; RESTORE LOOP COUNTER
	DEC		A					; DECREMENT LOOP COUNTER
	JZ		DOUBLE_WORD_LOOP1	; DECREMENT LOOP COUNTER
	INC		R1					; INCREMENT MEMORY ADDRESS
	LJMP	DOUBLE_WORD_LOOP

DOUBLE_WORD_LOOP1:
	ACALL	LCD_2NDLINE			; MOVE LCD CURSOR TO 2ND LINE
	MOV		DPTR, #SCROLL_PAGE
	ACALL	LCD_STRING			; WRITE "0. NEXT, 1. BACK"
	LJMP	SCROLL				; JUMP TO SCROLL FUNCTION


;------------------------------------
; SCROLL TO VEIW NEXT/PREVIOUS PAGE OF DATA
; WRITES: "0. NEXT, 1. BACK"
; READS INPUT FROM KEYPAD & SCROLLS NEXT OR BACK ACCORDINGLY
; IF '1' IS PRESSED ON LAST PAGE OF DATA, "END OF DATA." MESSAGE IS DISPLAYED
; IF '0' IS PRESSED ON FIRST PAGE OF DATA, "END OF DATA." MESSAGE IS DISPLAYED
;------------------------------------

SCROLL:
	ACALL	KEYPAD_READ			; READ INPUT VALUE FROM KEYPAD

	MOV		B, A				; HOLD INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #00H				; CHECK IF '0' KEY WAS PRESSED
	JZ		SCROLL_NEXT			; IF '0' PRESSED, SCROLL TO NEXT PAGE

	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF '1' KEY WAS PRESSED
	JZ		SCROLL_BACK			; IF '1' PRESSED, SCROLL BACK 1 PAGE

	ACALL	INVALID				; NEITHER '0' NOR '1' PRESSED. DISPLAY 'INVALID' MESSAGE
	LJMP	SCROLL				; CHECK FOR SCROLL INPUTS AGAIN

SCROLL_NEXT:
	MOV		A, R7				; RESTORE MEMORY SIZE COUNTER
	JZ		SCROLL_END			; END OF DATA
	INC		R1					; INCREMENT MEMORY ADDRESS
	DEC		R7					; DECREMENT BLOCK SIZE
	MOV		A, R1				; HOLD RAM POINTER IN ACCUMULATOR
	PUSH	A
	ACALL	LCD_CLEAR
	POP		A
	ACALL	MEMORY_ADDRESS_WRITE2; WRITE MEMORY ADDRESS TO LCD
	ACALL	SCROLL_NEXT_DATA_TYPE


SCROLL_BACK:
	MOV		A, R7				; RESTORE MEMORY SIZE COUNTER
	ADD		A, #01H
	CLR		C					; CLEAR CARRY FLAG			
	SUBB	A, 52H				; CHECK IF BACK AT STARTING MEM ADDRESS
	JZ		SCROLL_END			; IF AT STARTING MEM ADDRESS, DISPLAY "END OF DATA."
	MOV		R0, #INPUT_DATA_TYPE; LOAD DATA TYPE RAM ADDRESS
	MOV		A, @R0				; LOAD DATA TYPE FROM RAM
	MOV		B, A				; HOLD DATA TYPE IN REGISTER B
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H				; CHECK IF DATA TYPE = 'BYTE'
	JNZ		SCROLL_BACK_1		; DATA TYPE != 'BYTE', CHECK NEXT DATA TYPE
	DEC		R1					; DATA TYPE = 'BYTE', DECREMENT MEMORY ADDRESS
	LJMP	SCROLL_BACK_3		

SCROLL_BACK_1:
	MOV		A, B				; RESTORE DATA TYPE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #02H				; CHECK IF DATA TYPE = 'WORD'
	JNZ		SCROLL_BACK_2		; DATA TYPE != 'WORD', CHECK NEXT DATA TYPE
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	LJMP	SCROLL_BACK_3

SCROLL_BACK_2:					; DATA TPYE = 'DOUBLE WORD'
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS
	DEC		R1					; DECREMENT MEMORY ADDRESS

SCROLL_BACK_3:
	INC		R7					; INCREMENT BLOCK SIZE
	MOV		A, R1				; HOLD MEMORY ADDRESS IN ACCUMULATOR
	PUSH	A					; PUSH MEMORY ADDRESS ONTO THE STACK
	ACALL	LCD_CLEAR			; CLEAR LCD
	POP		A					; RESTORE MEMORY ADDRESS
	ACALL	MEMORY_ADDRESS_WRITE2; WRITE MEMORY ADDRESS TO LCD
	ACALL	SCROLL_BACK_DATA_TYPE; CHECK DATA TYPE & WRITE MEMORY DATA


SCROLL_END:
	MOV		DPTR, #SCROLL_END1
	ACALL	LCD_CLEAR			; CLEAR LCD
	ACALL	LCD_STRING			; WRITE "END OF DATA." ON LCD
	MOV		A, #03H				; LOAD DELAY COUNTER
	ACALL	DELAY_sec			; 3 SECOND DELAY
	ACALL	LCD_CLEAR			; CLEAR LCD
	ACALL	MEMORY_ADDRESS_WRITE1
	ACALL	DATA_WRITE			; RESTART DATA DISPLAY FROM STARTING MEM ADDRESS

;---------------------------------------------------------------------
;--------------------------- D-DUMP END ------------------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;--------------------------- INPUT TO ASCII --------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
; CONVERTS THE LOWER NIBBLE OF THE ACCUMULATOR FROM HEX TO ASCII
; RETURNS THE ASCII VALUE IN THE ACCUMULATOR

INPUT_TO_ASCII:
	MOV		B, A				; HOLD INPUT VALUE IN REGISTER B
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #00H
	JNZ		VALUE1				; CHECK IF INPUT VALUE = 0. IF NOT, CHECK IF = 1
	MOV		A, #30H				; IF = 0, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE1:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #01H
	JNZ		VALUE2				; CHECK IF INPUT VALUE = 1. IF NOT, CHECK IF = 2
	MOV		A, #31H				; IF = 1, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE2:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #02H
	JNZ		VALUE3				; CHECK IF INPUT VALUE = 2. IF NOT, CHECK IF = 3
	MOV		A, #32H				; IF = 2, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE3:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #03H
	JNZ		VALUE4				; CHECK IF INPUT VALUE = 3. IF NOT, CHECK IF = 4
	MOV		A, #33H				; IF = 3, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE4:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #04H
	JNZ		VALUE5				; CHECK IF INPUT VALUE = 4. IF NOT, CHECK IF = 5
	MOV		A, #34H				; IF = 4, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE5:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #05H
	JNZ		VALUE6				; CHECK IF INPUT VALUE = 5. IF NOT, CHECK IF = 6
	MOV		A, #35H				; IF = 5, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE6:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #06H
	JNZ		VALUE7				; CHECK IF INPUT VALUE = 6. IF NOT, CHECK IF = 7
	MOV		A, #36H				; IF = 6, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE7:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #07H
	JNZ		VALUE8				; CHECK IF INPUT VALUE = 7. IF NOT, CHECK IF = 8
	MOV		A, #37H				; IF = 7, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE8:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #08H
	JNZ		VALUE9				; CHECK IF INPUT VALUE = 8. IF NOT, CHECK IF = 9
	MOV		A, #38H				; IF = 8, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE9:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #09H
	JNZ		VALUE10				; CHECK IF INPUT VALUE = 9. IF NOT, CHECK IF = A
	MOV		A, #39H				; IF = 9, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE10:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0AH
	JNZ		VALUE11				; CHECK IF INPUT VALUE = A. IF NOT, CHECK IF = B
	MOV		A, #41H				; IF = A, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE11:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0BH
	JNZ		VALUE12				; CHECK IF INPUT VALUE = B. IF NOT, CHECK IF = C
	MOV		A, #42H				; IF = B, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE12:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0CH
	JNZ		VALUE13				; CHECK IF INPUT VALUE = C. IF NOT, CHECK IF = D
	MOV		A, #43H				; IF = C, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE13:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0DH
	JNZ		VALUE14				; CHECK IF INPUT VALUE = D. IF NOT, CHECK IF = E
	MOV		A, #44H				; IF = D, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE14:
	MOV		A, B				; RESTORE INPUT VALUE
	CLR		C					; CLEAR CARRY FLAG
	SUBB	A, #0EH
	JNZ		VALUE15				; CHECK IF INPUT VALUE = E. IF NOT, CHECK IF = F
	MOV		A, #45H				; IF = E, LOAD ASCII VALUE IN ACCUMULATOR
	RET

VALUE15:
	MOV		A, B				; RESTORE INPUT VALUE
	MOV		A, #46H				; IF = F, LOAD ASCII VALUE IN ACCUMULATOR
	RET

;---------------------------------------------------------------------
;--------------------------- INPUT TO ASCII END ----------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;--------------------------- MATRIX KEYPAD READ ----------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
; READS A 4 x 4 MATRIX KEYPAD FOR WHICH KEY IS PRESSED
; RETURNS THE VALUE OF THE PRESSED KEY VIA THE ACCUMULATOR
; PROCEDURE WILL NOT RETURN UNTIL A KEY IS PRESSED 

;   |1| |2| |3| |A|  ---- ROW 1 ------> P0.0
;   |4| |5| |6| |B|  ---- ROW 2 ------> P0.1
;   |7| |8| |9| |C|  ---- ROW 3 ------> P0.2
;   |E| |0| |F| |D|  ---- ROW 4 ------> P0.3

;    |   |   |   |
;    |   |   |    ------- COLUMN 4 ---> P0.7
;    |   |    ----------- COLUMN 3 ---> P0.6
;    |    --------------- COLUMN 2 ---> P0.5
;     ------------------- COLUMN 1 ---> P0.4


KEYPAD_READ:
	MOV		P0, #0FFH			; SET ALL BITS ON PORT 1 HIGH
	CLR		P0.0				; CLEAR PORT 0, BIT 0 (ROW 1)
	JB		P0.4, NEXT1			; CHECKS STATE OF COLUMN 1. JUMP IF HIGH
	MOV		A, #01H				; COLUMN 1 IS LOW. KEY '1' IS PRESSED
	RET

NEXT1:
	JB		P0.5, NEXT2			; CHECK STATE OF COLUMN 2. JUMP IF HIGH
	MOV		A, #02H				; COLUMN 2 IS LOW. KEY '2' IS PRESSED
	RET

NEXT2:
	JB		P0.6, NEXT3			; CHECK STATE OF COLUMN 3. JUMP IF HIGH
	MOV		A, #03H				; COLUMN 3 IS LOW. KEY '3' IS PRESSED
	RET

NEXT3:
	JB		P0.7, NEXT4			; CHECK STATE OF COLUMN 4. JUMP IF HIGH
	MOV		A, #0AH				; COLUMN 4 IS LOW. KEY 'A' IS PRESSED
	RET

NEXT4:
	SETB	P0.0				; SET PORT 0, BIT 0 (ROW 1)
	CLR		P0.1				; CLEAR PORT 0, BIT 1 (ROW 2)
	JB		P0.4, NEXT5			; CHECK STATE OF COLUMN 1. JUMP IF HIGH
	MOV		A, #04H				; COLUMN 1 IS LOW. KEY '4' IS PRESSED
	RET

NEXT5:
	JB		P0.5, NEXT6			; CHECK STATE OF COLUMN 2. JUMP IF HIGH
	MOV		A, #05H				; COLUMN 2 IS LOW. KEY '5' IS PRESSED
	RET

NEXT6:
	JB		P0.6, NEXT7			; CHECK STATE OF COLUMN 3. JUMP IF HIGH
	MOV		A, #06H				; COLUMN 3 IS LOW. KEY '6' IS PRESSED
	RET

NEXT7:
	JB		P0.7, NEXT8			; CHECK STATE OF COLUMN 4. JUMP IF HIGH
	MOV		A, #0BH				; COLUMN 4 IS LOW. KEY 'B' IS PRESSED
	RET

NEXT8:
	SETB	P0.1				; SET PORT 0, BIT 1 (ROW 2)
	CLR		P0.2				; CLEAR PORT 0, BIT 2 (ROW 3)
	JB		P0.4, NEXT9			; CHECK STATE OF COLUMN 1. JUMP IF HIGH
	MOV		A, #07H				; COLUMN 1 IS LOW. KEY '7' IS PRESSED
	RET

NEXT9:
	JB		P0.5, NEXT10		; CHECK STATE OF COLUMN 2. JUMP IF HIGH
	MOV		A, #08H				; COLUMN 2 IS LOW. KEY '8' IS PRESSED
	RET

NEXT10:
	JB		P0.6, NEXT11		; CHECK STATE OF COLUMN 3. JUMP IF HIGH
	MOV		A, #09H				; COLUMN 3 IS LOW. KEY '9' IS PRESSED
	RET

NEXT11:
	JB		P0.7, NEXT12		; CHECK STATE OF COLUMN 4. JUMP IF HIGH
	MOV		A, #0CH				; COLUMN 4 IS LOW. KEY 'C' IS PRESSED
	RET

NEXT12:
	SETB	P0.2				; SET PORT 0, BIT 2 (ROW 3)
	CLR		P0.3				; CLEAR PORT 0, BIT 3 (ROW 4)
	JB		P0.4, NEXT13		; CHECK STATE OF COLUMN 1. JUMP IF HIGH
	MOV		A, #0EH				; COLUMN 1 IS LOW. KEY 'E' IS PRESSED
	RET

NEXT13:
	JB		P0.5, NEXT14		; CHECK STATE OF COLUMN 2. JUMP IF HIGH
	MOV		A, #00H				; COLUMN 2 IS LOW. KEY '0' IS PRESSED
	RET

NEXT14:
	JB		P0.6, NEXT15		; CHECK STATE OF COLUMN 3. JUMP IF HIGH
	MOV		A, #0FH				; COLUMN 3 IS LOW. KEY 'F' IS PRESSED
	RET

NEXT15:
	JB		P0.7, KEYPAD_READ	; CHECK STATE OF COLUMN 4. JUMP IF HIGH
	MOV		A, #0DH				; COLUMN 4 IS LOW. KEY 'D' IS PRESSED
	RET

;---------------------------------------------------------------------
;--------------------------- MATRIX KEYPAD READ END ------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;--------------------------- LCD DRIVER ------------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------
; LCD_INIT ------- INITIALIZES LCD (16 x 2)
; LCD_2NDLINE ---- MOVES LCD CURSOR TO 2ND LINE, 1ST COLUMN 
; LCD_CHAR ------- WRITES CHARACTER HELD IN THE ACCUMULATOR TO LCD
; LCD_CLEAR ------ CLEARS LCD
; LCD_STRING ----- MOVE STRING TO DPTR 1ST. WRITES STRING ON LCD
; DELAY ---------- 1ms DELAY
; DELAY_ms ------- LOAD (n)ms INTO ACCUM. CALL FOR (n)ms DELAY
; LCD_CMD -------- ** NOT USED OUTSIDE OF LCD DRIVER **
; LCD_DATA ------- ** NOT USED OUTSIDE OF LCD DRIVER **

; RS ---> P3.0
; RW ---> P3.1
; EN ---> P3.2

; D0 ---> P1.0
; D1 ---> P1.1
; D2 ---> P1.2
; D3 ---> P1.3
; D4 ---> P1.4
; D5 ---> P1.5
; D6 ---> P1.6
; D7 ---> P1.7


;---------------------(n)sec DELAY PROCEDURE--------------------------
; CALLS DELAY PROCEDURE n # OF TIMES. n = VALUE LOADED INTO REG A

DELAY_sec:
	MOV		R5, A				; ACCUMULATOR HOLDS # OF sec DELAY NEEDED
DELAY_sec_1:
	MOV		R7, #04H			; 4 * 250ms DELAYS = 1000ms = 1sec
DELAY_sec_2:
	MOV		R6, #0FAH			; 250 * 1ms DELAYS = 250ms
DELAY_sec_3:
	ACALL	DELAY				; 1ms DELAY
	DJNZ	R6, DELAY_sec_3
	DJNZ	R7, DELAY_sec_2
	DJNZ	R5,	DELAY_sec_1
	RET


;---------------------(n)ms DELAY PROCEDURE---------------------------
; CALLS DELAY PROCEDURE n # OF TIMES. n = VALUE LOADED INTO REG A

DELAY_ms:
	MOV		R5, A				; REGISTER A HOLDS # OF ms DELAY NEEDED
JUMP:
	ACALL	DELAY				; 1ms DELAY
	DJNZ	R5, JUMP			; CONITUALLY DECREMENT R5 UNTIL 0
	RET

;---------------------1ms DELAY PROCEDURE-----------------------------
; DECREMENTS R4 FROM 255 TO 0 THEN DECREMENTS R3. 
; CONTINUES LOOPS UNTIL R3 IS 0. CREATES 12750 CLOCKS ~1ms.

DELAY:
	MOV		R3, #1				; LOAD 50 DEC INTO R3
HERE:
	MOV		R4, #1				; LOAD 255 DEC INTO R4
HERE2:
	DJNZ	R4, HERE2			; CONTINUALLY DECREMENT R4 UNTIL 0
	DJNZ	R3, HERE			; DECREMENTS R3 UNTIL 0
	RET

;---------------------LCD INITIALIZE PROCEDURE------------------------
; INITIALIZES THE LCD IN ACCORDANCE TO THE LCD DATA SHEET

LCD_INIT:
	MOV		A, #15				; 15ms DELAY
	ACALL	DELAY_ms

	MOV		A, #000H
	MOV		P1, A				; SET PORT 1 AS OUTPUT
	MOV		P3, A				; SET PORT 3 AS OUTPUT

	MOV		A, #30H				; FUNCTION SET COMMAND
	ACALL	LCD_CMD

	MOV		A, #5				; 5ms DELAY
	ACALL	DELAY_ms

	MOV		A, #30H				; FUNCTION SET COMMAND
	ACALL	LCD_CMD

	ACALL	DELAY				; 1ms DELAY

	MOV		A, #30H				; FUNCTION SET COMMAND
	ACALL	LCD_CMD

	MOV		A, #3CH				; FUNCTION SET COMMAND
	ACALL	LCD_CMD				; 8-BIT INTERFACE

	MOV		A, #08H				; DISPLAY OFF
	ACALL	LCD_CMD

	MOV		A, #06H				; ENTRY MODE SET
	ACALL	LCD_CMD

	MOV		A, #0FH				; DISPLAY ON
	ACALL	LCD_CMD

	ACALL	LCD_CLEAR			; CLEAR DISPLAY

	RET

;---------------------LCD DATA PROCEDURE------------------------------
; TRANSFERS DATA TO THE LCD	

LCD_DATA:
	SETB	P3.0				; RS = 1
	CLR		P3.1				; RW = 0
	ACALL	DELAY				; 1ms DELAY
	SETB	P3.2				; EN = 1
	ACALL	DELAY				; 1ms DELAY
	MOV		P1, A				; REGISTER A -> PORT 1
	ACALL	DELAY				; 1ms DELAY
	CLR		P3.2				; EN = 0
	RET

;---------------------LCD COMMAND PROCEDURE---------------------------
; USED TO EXECUTE ALL COMMANDS ON THE LCD

LCD_CMD:
	CLR		P3.0				; RS = 0
	CLR		P3.1				; RW = 0
	ACALL	DELAY				; 1ms DELAY
	SETB	P3.2				; EN = 1
	ACALL	DELAY				; 1ms DELAY
	MOV		P1, A				; REGISTER A -> PORT 1
	ACALL	DELAY				; 1ms DELAY
	CLR		P3.2				; EN = 0
	RET

;---------------------LCD CLEAR PROCEDURE-----------------------------
; CLEARS THE LCD

LCD_CLEAR:
	MOV		A, #01H
	ACALL	LCD_CMD
	MOV		A, #80H
	ACALL	LCD_CMD
	RET

;---------------------LCD CHAR PROCEDURE------------------------------
; WRITE A SINGLE CHARACTER ON THE LCD

LCD_CHAR:
	ACALL	LCD_DATA
	RET

;---------------------LCD 2ND LINE PROCEDURE--------------------------
; MOVES CURSORS TO THE SECOND LINE OF THE LCD

LCD_2NDLINE:
	MOV		A, #0C0H
	ACALL	LCD_CMD
	RET

;---------------------LCD STRING PROCEDURE----------------------------
; WRITES A STRING ON THE LCD 

LCD_STRING:
L3:
	CLR		A
	MOVC	A, @A+DPTR
	ACALL	LCD_DATA
	ACALL	DELAY
	INC		DPTR
	JZ		L4
	SJMP	L3
L4:
	RET

;---------------------------------------------------------------------
;--------------------------- LCD DRIVER END --------------------------
;*********************************************************************



;*********************************************************************
;---------------------------------------------------------------------
;--------------------------- STRINGS ---------------------------------
;---------------------------------------------------------------------
;---------------------------------------------------------------------

	ORG		400H

COURSE:
	DB		'ECEN4330', 0

MYNAME:
	DB		'C.W.B.', 0

D_DUMP:
	DB		'D-DUMP', 0

BLOCK_SIZE_0:
	DB		'ENTER MEM ADDR:', 0

BLOCK_SIZE_1:
	DB		'SELECT DATA', 0

BLOCK_SIZE_1B:
	DB		'TYPE:', 0

BLOCK_SIZE_2:
	DB		'1. BYTE, 2. WORD', 0

BLOCK_SIZE_3:
	DB		'3. DOUBLE WORD', 0

INVALID_INPUT:
	DB		'INVALID INPUT.', 0

DATA_SIZE:
	DB		'ENTER DATA SIZE:', 0

SEMI_COLON:
	DB		':', 0

SCROLL_PAGE:
	DB		'0. NEXT, 1. BACK', 0

SCROLL_END1:
	DB		'END OF DATA.', 0

	END

;---------------------------------------------------------------------
;--------------------------- STRINGS END -----------------------------
;*********************************************************************


